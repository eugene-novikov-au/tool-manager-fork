#!/usr/bin/env tm-env-bash
#
# Iterates over selected Tool Manager plugin directories and executes a
# specified command within each directory that is a Git repository.
#
# Usage: tm-plugin-each [filter_option] <command_and_args>
#
# Filter Options (mutually exclusive, last one specified wins):
#   -a, --available:  Iterate over all plugins defined in INI files (uses their 'dir' attribute).
#   -e, --enabled:    Iterate over currently enabled plugins.
#   -i, --installed:  Iterate over all installed plugin directories (default if no filter).
#
# Command and Arguments:
#   <command_and_args>: The command and its arguments to execute in each plugin directory.
#
# Examples:
#   tm-plugin-each git status
#   tm-plugin-each -e git remote -v
#   tm-plugin-each -a ls -l
#   tm-plugin-each --installed git pull
#
# Note:
#   The script only acts on plugin directories that are also Git repositories.
#   For known Git commands (status, add, show, commit, diff, log, restore, checkout, push),
#   'git' is automatically prepended. Other commands are run as is.
#

_tm::source::include .tm.script.sh .tm.plugins.sh

declare -A args
# Using --opts-* to capture the command and its arguments after '--'
_parse_args \
    --file "${BASH_SOURCE[0]}" \
    --opt-available "|flag=|group=filter|short=a|long=available|desc=Iterate over all available plugins (from INI 'dir' field)." \
    --opt-enabled "|flag=|group=filter|short=e|long=enabled|desc=Iterate over enabled plugins." \
    --opt-installed "|flag=|group=filter|short=i|long=installed|desc=Iterate over installed plugins (default)." \
    --opt-commands "|remainder|greedy|short=c|required|long=command|value=COMMAND|desc=The command (with args) to run.|example='git status --short', 'git add .'" \
    --opt-parallel "|short=p|flag|desc=Run in parallel. Will wait for all processes to complete" \
    --opt-quiet "|short=q|flag|desc=Reduce output. Don't print plugin details when looping" \
    --result args \
    -- "$@"

[[ "${args[quiet]}" == "1" ]] && level=debug || level=info

# Determine the command to run
full_command_string="${args[commands]:-':'}"
if [[ -z "$full_command_string" ]]; then
    _fail "No command specified to run. Use ' <command_and_args>'."
fi

# Determine which set of plugins to iterate over
# Filters are mutually exclusive; the last one specified wins.
# Default is installed plugins.
plugin_list_cmd="_tm::plugins::find_all_installed_plugin_ids" # Default
filter_description="installed"

if [[ -n "${args[available]:-}" ]]; then
    plugin_list_cmd="_tm::plugins::__get_all_available_plugin_ids" # Uses the new function
    filter_description="available (from INI 'dir' field, relative to $TM_PLUGINS_INSTALL_DIR)"
elif [[ -n "${args[enabled]:-}" ]]; then
    plugin_list_cmd="_tm::plugins::find_all_enabled_plugin_ids"
    filter_description="enabled"
elif [[ -n "${args[installed]:-}" ]]; then
    # This is the default, but explicit flag also sets it
    plugin_list_cmd="_tm::plugins::find_all_installed_plugin_ids"
    filter_description="installed"
fi

# Get the list of plugin directories
# For _tm::plugins::__get_all_available_dirs, these are dir names relative to $TM_PLUGINS_INSTALL_DIR
# For find_all_enabled_dirs/installed, these are absolute paths (symlinks or actual dirs)
declare -a plugin_ids_to_process
mapfile -t plugin_ids_to_process < <($plugin_list_cmd)

if [[ ${#plugin_ids_to_process[@]} -eq 0 ]]; then
    _warn "No plugins found for filter '$filter_description'. Nothing to do."
    exit 0
fi

git_commands_array=("status" "add" "show" "commit" "diff" "log" "restore" "checkout" "push")
# Extract the first word of the full_command_string to check against git_commands_array
first_command_word=$(echo "$full_command_string" | awk '{print $1}')

#
# Invoke a given command either waiting, or in a background job
#
_invoke(){
    if [[ "${args[parallel]:-}" == "1" ]]; then
        eval "$@" &
    else
        eval "$@"
    fi
}

declar -A plugin
for plugin_id in "${plugin_ids_to_process[@]}"; do
    _tm::util::parse::plugin_id plugin "$plugin_id"

    actual_plugin_dir="${plugin[install_dir]}"
    if [[ ! -d "$actual_plugin_dir" ]]; then
        _warn "Directory '$actual_plugin_dir' (derived from '$plugin_id') does not exist. Skipping."
        continue
    fi
    _pushd "$actual_plugin_dir"
        if [[ -d .git ]]; then
            _log $level "In $actual_plugin_dir (Branch: '$(git branch --show-current 2>/dev/null || echo "N/A")' Repo: $(git remote -v | awk '/\(push\)$/{print $2; exit}')) ==>"
            
            is_git_command=0
            for gc in "${git_commands_array[@]}"; do
                if [[ "$first_command_word" == "$gc" ]]; then
                    is_git_command=1
                    break
                fi
            done

            if [[ "$is_git_command" -eq 1 ]]; then
                _log $level "running: git $full_command_string"
                _invoke "git $full_command_string" || _warn "Command 'git $full_command_string' failed in $actual_plugin_dir"
            else
                _log $level "running: '$full_command_string'"
                _invoke "$full_command_string" || _warn "Command '$full_command_string' failed in $actual_plugin_dir"
            fi
        else
            _debug "Skipping '$actual_plugin_dir' as it is not a Git repository."
        fi
    _popd
done

if [[ "${args[parallel]:-}" == "1" ]]; then
    _info "waiting for parallel commands to complete..."
    wait
    _info "..done"
fi